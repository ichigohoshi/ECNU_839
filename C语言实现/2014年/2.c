#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define TIMES 6000000

struct T
{
    int key, value;
};

int main()
{
    int i;
    struct T a[12];
    for(i = 0; i < 12; i++)
    {
        a[i].key = i + 1;
        a[i].value = 0;
    }
    srand((unsigned) time(0));
    for(i = 0; i < TIMES; i++)
    {
        int v = (rand() % 6 + 1) + (rand() %6 + 1);
        a[v - 1].value++;
    }
    for(i = 0; i < 12; i++)
        printf("%2d: %.2f\n", a[i].key, (double)a[i].value/TIMES);
    return 0;
}


/************ 解题要点 ************/
/*
Monte Carlo算法核心思想是用大量的随机事件求得概率，而随机事件次数越多，
与事件的真正概率就越接近，故本题可如下解：
for循环中v可能出现的数值为1~11，其分别可能的情况如下：
0:                                      0
1: (1,1)                                1   1/36
2: (1,2) (2,1)                          2   2/36
3: (1,3) (2,2) (3,1)                    3   3/36
4: (1,4) (2,3) (3,2) (4,1)              4   4/36
5: (1,5) (2,4) (3,3) (4,2) (5,1)        5   5/36
6: (1,6) (2,5) (3,4) (4,3) (5,2) (6,1)  6   6/36
7: (2,6) (3,5) (4,4) (5,3) (6,2)        5   5/36
8: (3,6) (4,5) (5,4) (6,3)              4   4/36
9: (4,6) (5,5) (6,4)                    3   3/36
10:(5,6) (6,5)                          2   2/36
11:(6,6)                                1   1/36
总可能为：      6*6 or (1+5)*5/2*2+6 = 36
*/
/************ 解题要点 ************/
